package generator

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const (
	ReadmeFileName         = "README.md"
	CommandReadmeTemplate  = "<!--- This file is autogenerated from the files in docsgenerator/templates/%s --->\n&larr; [back to Commands](../README.md)\n\n# `om %s`\n\n%s\n\n## Command Usage\n```\n%s```\n\n%s"
	ReadmeTemplate         = "<!--- This file is autogenerated from docsgenerator/templates/README-BEFORE.md and docsgenerator/templates/README-AFTER.md --->\n%s\n\n# Commands\n\n%s\n\n%s"
	ReadmeBeforeTemplate   = "<!--- Anything in this file will be placed before the command list in docs/README.md file --->"
	ReadmeBeforeFileName   = "README_BEFORE.md"
	ReadmeAfterTemplate    = "<!--- Anything in this file will be placed after the command list in docs/README.md file --->"
	ReadmeAfterFileName    = "README_AFTER.md"
	DescriptionFileName    = "EXPANDED_DESCRIPTION.md"
	DescriptionTemplate    = "<!--- Anything in this file will be used instead of the default command description in the final docs/%s/README.md file --->"
	AdditionalInfoFileName = "ADDITIONAL_INFO.md"
	AdditionalInfoTemplate = "<!--- Anything in this file will be appended to the final docs/%s/README.md file --->"
)

//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 -generate
//counterfeiter:generate -o ../fakes/executor.go --fake-name Executor . executor
type executor interface {
	GetCommandHelp(commandName string) ([]byte, error)
	GetCommandNamesAndDescriptions() (map[string]string, error)
	GetDescription(commandName string) (string, error)
	RunOmCommand(args ...string) ([]byte, error)
}

type Generator struct {
	templatesDir string
	docsDir      string
	executor     executor
	stdout       io.Writer
}

func NewGenerator(templatesDir string, docsDir string, executor executor, stdout io.Writer) Generator {
	return Generator{
		templatesDir: templatesDir,
		docsDir:      docsDir,
		executor:     executor,
		stdout:       stdout,
	}
}

func (g *Generator) GenerateDocs() error {
	commandDescriptions, err := g.executor.GetCommandNamesAndDescriptions()
	if err != nil {
		return fmt.Errorf("could not get commands: %s", err)
	}

	err = g.createTemplateDirs(commandDescriptions)
	if err != nil {
		return fmt.Errorf("could not create template dirs: %s", err)
	}

	err = g.cleanupExtraDirs(g.templatesDir, commandDescriptions)
	if err != nil {
		return fmt.Errorf("could not clean up template dirs: %s", err)
	}

	templateDirs, err := g.getDirectoryContents(g.templatesDir, true)
	if err != nil {
		return fmt.Errorf("could not generate directory contents: %s", err)
	}

	err = g.writeReadme(commandDescriptions)
	if err != nil {
		return fmt.Errorf("could not write readme: %s", err)
	}

	for _, templateDir := range templateDirs {
		err = g.writeCommandReadme(templateDir, filepath.Base(templateDir))
		if err != nil {
			return fmt.Errorf("could not write template dir %s: %s", templateDir, err)
		}
	}

	err = g.cleanupExtraDirs(g.docsDir, commandDescriptions)
	if err != nil {
		return fmt.Errorf("could not clean up docs dirs: %s", err)
	}

	return nil
}

func (g *Generator) writeCommandReadme(templateDir string, commandName string) error {
	descriptionContents, err := getFileContents(filepath.Join(templateDir, DescriptionFileName))
	if err != nil {
		return err
	}

	additionalInfoContents, err := getFileContents(filepath.Join(templateDir, AdditionalInfoFileName))
	if err != nil {
		return err
	}

	err = os.Mkdir(filepath.Join(g.docsDir, commandName), 0755)
	if err != nil && !os.IsExist(err) {
		return err
	}

	f, err := os.Create(filepath.Join(g.docsDir, commandName, ReadmeFileName))
	if err != nil && !os.IsExist(err) {
		return err
	}

	if len(strings.Split(descriptionContents, "\n")) == 1 && descriptionContents == fmt.Sprintf(DescriptionTemplate, commandName) {
		descriptionContents, err = g.executor.GetDescription(commandName)
		if err != nil {
			return err
		}
	}

	additionalInfoContents = emptyIfOnlyTemplate(additionalInfoContents, fmt.Sprintf(AdditionalInfoTemplate, commandName))
	usage, err := g.executor.GetCommandHelp(commandName)
	if err != nil {
		return err
	}

	_, err = f.Write([]byte(fmt.Sprintf(CommandReadmeTemplate, commandName, commandName, descriptionContents, usage, additionalInfoContents)))
	if err != nil {
		return err
	}

	err = f.Close()
	if err != nil {
		return err
	}

	return nil
}

func (g *Generator) writeReadme(commandDescriptions map[string]string) error {
	var commandTable []string
	for commandName, commandDescription := range commandDescriptions {
		commandTable = append(commandTable, fmt.Sprintf("| [%s](%s/README.md) | %s |", commandName, commandName, commandDescription))
	}
	sort.Strings(commandTable)
	commandTable = append([]string{"| Command | Description |", "| ------------- | ------------- |"}, commandTable...)

	readmeBeforeContents, err := getFileContents(filepath.Join(g.templatesDir, ReadmeBeforeFileName))
	if err != nil {
		return err
	}

	readmeAfterContents, err := getFileContents(filepath.Join(g.templatesDir, ReadmeAfterFileName))
	if err != nil {
		return err
	}

	f, err := os.Create(filepath.Join(g.docsDir, ReadmeFileName))
	if err != nil {
		return err
	}

	readmeBeforeContents = emptyIfOnlyTemplate(readmeBeforeContents, ReadmeBeforeTemplate)
	readmeAfterContents = emptyIfOnlyTemplate(readmeAfterContents, ReadmeAfterTemplate)

	_, err = f.Write([]byte(fmt.Sprintf(ReadmeTemplate, readmeBeforeContents, strings.Join(commandTable, "\n"), readmeAfterContents)))
	if err != nil {
		return err
	}

	err = f.Close()
	if err != nil {
		return err
	}

	return nil
}

func emptyIfOnlyTemplate(contents string, template string) string {
	if len(strings.Split(contents, "\n")) == 1 && contents == template {
		return ""
	}

	return contents
}

func (g *Generator) createTemplateDirs(commands map[string]string) error {
	err := g.createReadmeTemplates(map[string]string{
		ReadmeBeforeFileName: ReadmeBeforeTemplate,
		ReadmeAfterFileName:  ReadmeAfterTemplate,
	})
	if err != nil {
		return err
	}

	for command := range commands {
		err = os.Mkdir(filepath.Join(g.templatesDir, command), 0755)
		if err != nil {
			if os.IsExist(err) {
				continue
			}

			return err
		}

		commandTemplateDir := filepath.Join(g.templatesDir, command)

		err := g.createCommandTemplates(command, commandTemplateDir, map[string]string{
			AdditionalInfoFileName: AdditionalInfoTemplate,
			DescriptionFileName:    DescriptionTemplate,
		})
		if err != nil {
			return err
		}

		fmt.Fprintf(g.stdout, "Added %s templates at: templates/%s\n", command, command)
	}

	return nil
}

func (g *Generator) createReadmeTemplates(readmeTemplates map[string]string) error {
	for fileName, template := range readmeTemplates {
		filePath := filepath.Join(g.templatesDir, fileName)
		if fileExists(filePath) {
			continue
		}

		f, err := os.Create(filePath)
		if err != nil {
			return err
		}

		if template != "" {
			_, err = f.Write([]byte(template))
			if err != nil {
				return err
			}

			err = f.Close()
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Generator) createCommandTemplates(command string, commandTemplateDir string, fileTemplates map[string]string) error {
	for fileName, template := range fileTemplates {
		filePath := filepath.Join(commandTemplateDir, fileName)
		if fileExists(filePath) {
			continue
		}

		f, err := os.Create(filePath)
		if err != nil {
			return err
		}

		if template != "" {
			_, err = f.Write([]byte(fmt.Sprintf(template, command)))
			if err != nil {
				return err
			}

			err = f.Close()
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Generator) getDirectoryContents(dir string, onlyDirectories bool) ([]string, error) {
	var templateDirs []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if path == dir {
			return nil
		}

		if !onlyDirectories || info.IsDir() {
			templateDirs = append(templateDirs, path)
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return templateDirs, nil
}

func (g *Generator) cleanupExtraDirs(baseDir string, commandDescriptions map[string]string) error {
	dirs, err := g.getDirectoryContents(baseDir, true)
	if err != nil {
		return err
	}

	for _, dir := range dirs {
		var commandExists bool
		for command := range commandDescriptions {
			if strings.Contains(dir, command) {
				commandExists = true
			}
		}

		if !commandExists {
			err := os.RemoveAll(dir)
			if err != nil {
				return err
			}

			fmt.Fprintf(g.stdout, "Removed %s at: %s/%s\n", filepath.Base(baseDir), filepath.Base(baseDir), filepath.Base(dir))
		}
	}

	return nil
}

func getFileContents(filepath string) (string, error) {
	contents, err := os.ReadFile(filepath)
	if err != nil {
		return "", err
	}

	return string(contents), nil
}

func fileExists(fileName string) bool {
	info, err := os.Stat(fileName)
	if os.IsNotExist(err) {
		return false
	}

	return !info.IsDir()
}
